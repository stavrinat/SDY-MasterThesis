#!/usr/bin/env python
# coding: utf-8

# https://github.com/eellak/gsoc2018-spacy/blob/dev/spacy/lang/el/res/modules/emotions.py
# https://github.com/MKLab-ITI/greek-sentiment-lexicon
# we used code from the above links (references to Giannis Daras for part of the sentiment_analysis_process) and also added some prototype of our own
#The lexicon was generated by Adam Tsakalidis (CERTH-ITI, now University of Warwick) in collaboration with Symeon Papadopoulos #(CERTH-ITI) and with the contribution of Ourania Voskaki (Centre for Greek Language) and Kyriaki Ioannidou (Centre for Greek #Language) and Christina Boididou (CERTH-ITI). For feedback and suggestions, please get in touch with adam.tsakalidis@gmail.com #and papadop@iti.gr.


import spacy
import operator
import pandas as pd
import tiger_manage_tokens as tmt
from collections import defaultdict
from spacy import displacy
from spacy.lang.el import Greek

nlpGR = Greek()

subj_scores = {
    'N/A': 0,
    'OBJ': 0,
    'SUBJ-': 0.5,
    'SUBJ+': 1,
}

emotion_scores = {
    'N/A': 0,
    '1.0': 0.2,
    '2.0': 0.4,
    '3.0': 0.6,
    '4.0': 0.8,
    '5.0': 1,
}

polarity_scores = {
    'N/A': 0,
    'BOTH': 0,
    'NEG': -1,
    'POS': 1
}

def load_greek_sentiment_lexicon():
    indexes = {}
    df = pd.read_csv('greek_sentiment_lexicon.tsv',sep='\t')
    df = df.fillna('N/A')
    for index, row in df.iterrows():
        df.at[index, 'Term'] = row['Term'].split(' ')[0]
        indexes[df.at[index, "Term"]] = index
    #print((indexes))
    #print(df)
    return indexes,df
    

# calculate subjectivity , polarity and emotions for a token
# add the values that have been assigned from the 4 annotators
def calc_scores(indx,df):
    polarity = {'N/A':0,'BOTH':0, 'NEG':0, 'POS':0} # keeps polarity scores
    sub = a = d = f = h = sad = sur = 0.0
    for col in range(1,5):
        polarity[str(df.at[indx, 'Polarity'+str(col)])]  += 1 
        sub += subj_scores[str(df.at[indx,'Subjectivity'+str(col)])]
        a += emotion_scores[str(df.at[indx, 'Anger'+str(col)])]
        d += emotion_scores[str(df.at[indx, 'Disgust'+str(col)])]
        f += emotion_scores[str(df.at[indx, 'Fear'+str(col)])]
        h += emotion_scores[str(df.at[indx, 'Happiness'+str(col)])]
        sad += emotion_scores[str(df.at[indx,'Sadness'+str(col)])]
        sur += emotion_scores[str(df.at[indx, 'Surprise'+str(col)])]
    
    prevail_polarity = max(polarity.items(), key=operator.itemgetter(1))[0]

    return prevail_polarity,sub,a,d,f,h,sad,sur

# method that calculates subjectivity and polarity and which is the most
# prevail emotion that is being illustrated in a certain token
def most_prevail_emotion(indx,df):
    polarity,sub,a,d,f,h,sad,sur = calc_scores(indx,df)
    emotions = {'anger':(a/4.0),'disgust':(d/4.0),'fear':(f/4.0),'happiness':(h/4.0),'sadness':(sad/4.0), 'surprise':(sur/4.0)}
    prevail_emotion = max(emotions.items(), key=operator.itemgetter(1))[0]
    return polarity,sub,prevail_emotion
    
def max_metrics(metrics):
    a = metrics['anger_score']
    d = metrics['disgust_score']
    f = metrics['fear_score']
    h = metrics['happiness_score']
    sad = metrics['sadness_score']
    sur = metrics['surprise_score']
    emotions = {1:a, 2:d, 3:f, 4:h , 5:sad, 6:sur}
    
    if a == d == f == h == sad == sur == 0:
        return 0
    return max(emotions.items(),key=operator.itemgetter(1))[0]

    
    
# sentiment_analysis_process1 is a method that analysis every token 
# and 
# 1. check to see if the token exists in greek sentiment lexicon
# 2. if yes, then calculates the subjectivity, the polarity and the emotions
# for that particular token and adds the scores to variables that keep the total score
# (for each one of anger, happiness,sadness etc) from all the existing tokens
# 3. returns the results
# the results illustrate the rates for each emotion in the answers that were given from users, as a whole
# for example "anger: what is the rate of anger that the answers of the users depict?" (similar for the 
# rest of the emotions) , and there might be a sample of answers that rates of different emotions
# are the same or very very close (for example "the answers of the users depict 70% surprise and 75% happiness at 
# the same time) 
def sentiment_analysis_process1(doc):
    # 1. load greek sentiment lexicon
    indexes,df = load_greek_sentiment_lexicon()
    
    # 2. initialize variables that keep emotions scores to 0
    subjectivity_score = anger_score = disgust_score = fear_score = happiness_score = sadness_score = surprise_score = 0
    polarity = {'N/A':0,'BOTH':0, 'NEG':0, 'POS':0} # keeps polarity scores
    matched_tokens = 0

    # 3. search for tokens that are included in greek sentiment lexicon
    # and are expressing an emotion
    for token in doc:
        # 3.1 search if token is include in greek sentiment lexicon
        # find_similar() examines all possible terms in the lexicon
        # to find if there is an identical term or a term with the same stem
        indx = tmt.find_similar(token,indexes)
        
        # 3.2 if token is included (or is similar with a term in greek sentiment lexicon
        # we proceed with the next steps of sentiment analysis
        if (indx != 0):
            #print(token,indx,tmt.get_key(indx,indexes),token.pos_)
            #calculate scores for subjectivity, polarity and emotions for that token
            # that was found in greek sentiment lexicon
            matched_tokens += 1
            p,sub,a,d,f,h,sad,sur = calc_scores(indx,df)
            
            # add the above results to scores
            # each token's score is being divided by 4, because 4 are the annotators 
            # that assigned values in subjectivity, polarity and emotions in the lexicon
            # so, we calculate the medium value of each one
            # for example if token = "αισθάνομαι" then annotator 1 gave value 5, annotator 2 gave 
            # value 1, annotator 3 gave 'N/A' and annotator 4 gave value 5, so medium value is 5+1+0+5 = 11
            # 11/4.0 = 2.75
            subjectivity_score += (sub/4.0)
            polarity[p] +=  1

            anger_score += (a/4.0)
            disgust_score += (d/4.0)           
            fear_score += (f/4.0)            
            happiness_score += (h/4.0)            
            sadness_score += (sad/4.0)           
            surprise_score += (sur/4.0)            

    #4 return emotions
    try:
        print('Subjectivity: ' + str(subjectivity_score/matched_tokens * 100)+'%')
        for k in polarity.keys():
            polarity[k] = (polarity[k]/matched_tokens)*100
            print('Polarity : '+k+":" + str(polarity[k])+'%')
        emotions = {'anger': (anger_score/matched_tokens * 100), 'disgust': (disgust_score/matched_tokens * 100), 'fear':(fear_score/matched_tokens * 100), 'happiness':(happiness_score/matched_tokens * 100), 'sadness': (sadness_score/matched_tokens * 100), 'surprise': (surprise_score/matched_tokens * 100)}
        emotion = max(emotions.items(), key=operator.itemgetter(1))[0]
        print(emotions)
        if (emotions[emotion] == 0):
            print('Unable to detect emotion')
        else:
            print('Main emotion: ' + emotion + '. Emotion score: ' + str(emotions[emotion]) + '%')
    except:
        print('No matched tokens')

    return emotions,polarity



def sentiment_analysis_process2(doc):
    # 1. load greek sentiment lexicon
    indexes,df = load_greek_sentiment_lexicon()
    
    # 2. initialize variables that keep emotions scores to 0
    metrics = {'subjectivity_score':0,'anger_score':0,'disgust_score':0,
               'fear_score':0,'happiness_score':0,'sadness_score':0,'surprise_score':0}
    polarity = {'N/A':0,'BOTH':0, 'NEG':0, 'POS':0} # keeps polarity scores
    matched_tokens = 0


    # 3. search for tokens that are included in greek sentiment lexicon
    # and are expressing an emotion
    for token in doc:
        # 3.1 search if token is include in greek sentiment lexicon
        # find_similar() examines all possible terms in the lexicon
        # to find if there is an identical term or a term with the same stem
        indx = tmt.find_similar(token,indexes)
        
        # 3.2 if token is included (or is similar with a term in greek sentiment lexicon
        # we proceed with the next steps of sentiment analysis
        if (indx != 0):
            #print(token,indx,tmt.get_key(indx,indexes),token.pos_)
            #calculate scores for subjectivity, polarity and most prevail emotion for that token
            # that was found in greek sentiment lexicon
            matched_tokens += 1
            p,sub,prevail_emotion = most_prevail_emotion(indx,df)
            
            metrics['subjectivity_score'] += (sub/4.0)
            polarity[p] += 1
            metrics[prevail_emotion+"_score"] += 1       
            #print(prevail_emotion)

    #4 return emotions
    try:
        print('Subjectivity: ' + str(metrics['subjectivity_score']/matched_tokens * 100)+'%')
        for k in polarity.keys():
            polarity[k] = (polarity[k]/matched_tokens)*100
            print('Polarity : '+k+":" + str(polarity[k])+'%')
        emotions = {'anger': (metrics['anger_score']/matched_tokens * 100), 
                    'disgust': (metrics['disgust_score']/matched_tokens * 100), 'fear':(metrics['fear_score']/matched_tokens * 100), 'happiness':(metrics['happiness_score']/matched_tokens * 100), 'sadness': (metrics['sadness_score']/matched_tokens * 100), 'surprise': (metrics['surprise_score']/matched_tokens * 100)}
        
        emotion = max(emotions.items(), key=operator.itemgetter(1))[0]
        print(emotions)
        if (emotions[emotion] == 0):
            print('Unable to detect emotion')
        else:
            print('Main emotion: ' + emotion + '. Emotion score: ' + str(emotions[emotion]) + '%')
    except:
        print('No matched tokens')

    return emotions,polarity

def sentiment_analysis_process3(answer):
    # 1. load greek sentiment lexicon
    indexes,df = load_greek_sentiment_lexicon()
    
    # 2. initialize variables that keep emotions scores to 0
    metrics = {'subjectivity_score':0,'anger_score':0,'disgust_score':0,
               'fear_score':0,'happiness_score':0,'sadness_score':0,'surprise_score':0}
    polarity = {'N/A':0,'BOTH':0, 'NEG':0, 'POS':0} # keeps polarity scores
    matched_tokens = 0

    # 3. search for tokens that are included in greek sentiment lexicon
    # and are expressing an emotion
    for token in answer[0]:
        # 3.1 search if token is include in greek sentiment lexicon
        # find_similar() examines all possible terms in the lexicon
        # to find if there is an identical term or a term with the same stem
        indx = tmt.find_similar(token,indexes)
        
        # 3.2 if token is included (or is similar with a term in greek sentiment lexicon
        # we proceed with the next steps of sentiment analysis
        if (indx != 0):
           
            #calculate scores for subjectivity, polarity and most prevail emotion for that token
            # that was found in greek sentiment lexicon
            p,sub,prevail_emotion = most_prevail_emotion(indx,df)
            
            metrics['subjectivity_score'] += (sub/4.0)
            metrics[prevail_emotion+"_score"] += 1       
            #print(prevail_emotion)
   
    # go to answer vector and denote with value 1 the
    # emotion that has prevail for this answer, and left the 
    # rest of the vector values equal to 0
    emotion = max_metrics(metrics)
    if emotion != 0:
        answer[emotion] = 1

